So we have a few components:
serverprotocol, serverfactory, resources, error pages, and messages

WHAT IS IT?

<code>profx</code> is quite simply a series of classes designed to make building http
servers incredibly simple. And the way it does this is by providing you with
a few central components: a http request object, a http response object, a
http resource (more on that in a second), and then a server protocol and factory.
These objects in and of themselves are powerful, but their real power (in my
unbiased opinion) is how they fit together.

In <code>profx</code> everything that you do centers around implementing resources.
A resource is a special class which gets sent http request objects from your
server and generates an http response object. Your server can have one or many
of these resources and each resource is added to your server factory with a simple
method. When you add a resource, you also supply a path at the same time. This
path is very important. Here's why. Every time your server gets a request from some client
it will parse out the url's path.  It will then look through the paths that
you have entered with each resource and find the path that best matches (if
there is one), where a match is better if it is more specific. For example
if we have the url path <code>/boston/docs/page.html</code> and we have
resource 1 attached to the path <code>/boston</code>, resource 2 attached to
the path <code>/boston/docs</code>, and resource 3 attached to the path
<code>/newyork</code>, then resources 1 and 2 will both match (3 won't)
but resource 2 will be chosen because its path is more specific. If
resource 2 had been attached to the path <code>/boston/images</code> it
wouldn't have matched at all and so resource 1 would have been chosen.

In this way <code>profx</code> allows you to create resources which create
responses however you want and attaches them to specific url paths, therefore
holding true to the nature of HTTP.

Now, for anyone who is familiar with <code>twisted</code> you know that there
is a resource based server factory and resource classes in twisted already.
So why have I done all of this? This brings us to the other strength of
<code>profx</code>. With <code>profx</code>, unlike <code>twisted</code>'s
version of the same thing, within the resource class you have complete
and easy access to the entire request that you are now responding too.
This means you can look at things like cookies (which is actually the main
reason I wrote all this stuff).

So <code>profx</code> is a resource based server that gives you complete and
easy access to all parts of the requests you handle while also taking advantage
of the power <code>twisted</code>.

So now that we have an overview of <code>profx</code>, let's look at the details.
We will start with the message objects, the go to the resource class, and finally
look at the server protocol and factory.

MESSAGE OBJECTS

First of all, there is a lot more to the message objects than I am going
to go through here. What I am going to tell you is how <i>you</i> can
read request objects and how <i>you</i> can create response objects. But
there is a lot more to these objects, all of which aids the server in handling
them, turning them into real http messages, and reading in requests.

READING REQUESTS

So the first thing you are going to need to know when writing up you resources
is how to read http request objects (which I am just going to refer to as
requests from now on).

In short to each request there are a number of attributes, each which holds
an object representing the particular piece of the request. The attributes
you'll want to access are the following ones:

<ul>
<li><code>version</code></li>
<li><code>headers</code></li>
<li><code>header_names</code></li>
<li><code>body</code></li>
<li><code>has_body</code></li>
<li><code>url</code></li>
<li><code>method</code></li>
</ul>

Let's go through each of these in turn

VERSION

The <code>version</code> attribute returns a <code>Version</code> object.

What do you need to know about this object? You can access the version number
at the <code>number</code> attribute of any one of these objects. That and
the default is 1.1.

HEADERS

The <code>headers</code> attribute returns a list of <code>Header</code> objects.

Each of these <code>Header</code> objects has an attribute <code>name</code>
which is the name of the particular header, and an attribute <code>values</code>
which is a list containing all of the values that header had in the request
message (even if it was just one).

HEADER_NAMES

The <code>header_names</code> attribute returns a list containing all of the
names of the headers in your request object. This is useful for quickly
check to see if a particular header is in headers.

BODY

The <code>body</code> attribute returns a the body of your request message
if there was one and '' if not.

HAS_BODY

The <code>has_body</code> attribute is simply a boolean that lets you know
if the request has a body.

URL

The <code>url</code> attribute has a <code>Url</code> object attached to it.

The url object has a series of attributes all corresponding to a part of
the request url. Each of the following named things is an attribute of the url:

[scheme:][[//][username:password@]host[:port]][path][?query][#fragment]

So for example you can access the path using <code>Url.path</code>. All of these
pieces are by default <code>None</code> if not specified by the request.

METHOD

The <code>method</code> attribute has a <code>Method</code> object attached to
it.

This object has a <code>method</code> attribute which holds the method name
in string form. This name will be all caps.

And with that you can access all parts of the request you could every want!

CREATING RESPONSES

First I should note that with the exception of the <code>url</code> and the
<code>method</code> attributes, all of the above attributes are available to
you in the response object. <code>version</code> defaults to a <code>Version</code>
object with number 1.1, <code>headers</code> and <code>header_names</code> default
to empty lists, <code>body</code> defaults to an empty string, and <code>has_body</code>
defaults to <code>False</code>. <b>Only use these attributes to check what you have
already done, don't use them to set things!</b>

To create a response object you first must initialize a <code>profx.httpmessage.Response</code>
object. The constructor for this object takes no inputs.

On initialization the response object will have a <code>Status</code> object
assigned to it with a status code of 200. Don't worry, you can change this if you
want.

Now that you have initialized the object you are going to want to set the response's
various attributes. You can do this with the following methods (all of which
are attached to the response object).

SetStatus

You can input a <code>Status</code> object into <code>SetStatus</code> to set
the status code and message of your response. A <code>profx.httpmessage.Status</code> object is
initialized with a number as input. This number is your status' code. Note
that you do not provide the message; this will be done automatically for you.

SetVersion

You can input a <code>Version</code> object into <code>SetVersion</code> to set
the version of your response message. A <code>profx.httpmessage.Version</code>
object is initialized with a float (of the form a.b) that is the version number
you want to use (default is 1.1).

AddHeader

You can input a <code>Header</code> object into <code>AddHeader</code> to
add the header to the list of headers.

A <code>profx.httpmessage.Header</code> object is initialized with a
name and an optional value. If you add the value it will be the first element
in your values list.

You can add an additional values with <code>SetValue</code> which just takes
your values as input.

SetBody

You can input a string into <code>SetBody</code> to add a body to your
response; note that this will automatically set <code>has_body</code> to
<code>True</code>.

And with that you can control everything in your response.

For testing purposes, if you want to see what you response looks like
in http message form, just call the <code>Write</code> method on your
response object (without any inputs)

RESOURCES
